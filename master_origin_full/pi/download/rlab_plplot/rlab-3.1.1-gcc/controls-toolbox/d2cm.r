//--------------------------------------------------------------------------
//
// d2cm
//
// Syntax: </ac;bc;cc;dc/> = d2cm(a,b,c,d,Ts,method,w)
//         R = d2cm(num,den,Ts,method)
//         where R.num = numerator
//               R.den = denominator
//
//	Conversion of discrete LTI systems to continuous-time.
//
//	</Ac;Bc;Cc;Dc/> = D2CM(A,B,C,D,Ts,method) converts the discrete-
//	time state-space system to continuous-time using method:
//	  "zoh"	        Convert to continuous time assuming a zero order
//	                hold on the inputs.
//	  "foh"	        Convert to continuous time assuming a first order
//	                hold on the inputs.
//	  "tustin"      Convert to continuous time using the bilinear 
//	                (Tustin) approximation to the derivative.
//	  "prewarp"     Convert to continuous time using the bilinear 
//	                (Tustin) approximation with frequency prewarping.
//	                Specify the critical frequency with an additional
//	                argument, i.e. D2CM(A,B,C,D,Ts,'prewarp',Wc)
//	  "matched"     Convert the SISO system to continuous time using
//	                the matched pole-zero method.
//
//	R = d2cm(num,den,Ts,method) converts the discrete-time
//	polynomial transfer function G(z) = num(z)/den(z) to continuous
//	time, G(s) = R.num(s)/R.den(s), using method.
//
//	See also: d2c, and c2dm.
//--------------------------------------------------------------------------

require abcdchk d2c esort roots ss2tf ss2zp tf2ss tf2zp tfchk

d2cm = function(a,b,c,d,Ts,method,w)
{
  global(eps)
  
  if (nargs < 3 || nargs > 7 ) {
     error("Wrong number of input arguments");
  }

  tol = 1.e-4; // Tolerance for 'foh' integrator and zero checking

  tf = 0;
  // --- Determine which syntax is being used ---
  if (nargs==3) {
    // Transfer function without method, assume 'zoh'
    tmp = tfchk(a,b);
    Ts = c;
    method = "zoh";
    </a;b;c;d/> = tf2ss(tmp.num,tmp.den);
    tf = 1;

  else if (nargs==4) {
    // Transfer function with method.
    tmp = tfchk(a,b);
    Ts = c;
    method = d;
    </a;b;c;d/> = tf2ss(tmp.num,tmp.den);
    tf = 1;

  else if (nargs==5) {
    if (isstring(d) ) {
      // Transfer function with method and prewarp const.
      tmp = tfchk(a,b);
      w = Ts;
      Ts = c;
      method = d;
      </a;b;c;d/> = tf2ss(tmp.num,tmp.den); 
      tf = 1;
    else			// State space system without method, assume 'zoh'
      msg = abcdchk(a,b,c,d);
      if (msg != "") { error(msg); }
      method = "zoh";
    }

  else			
    // State space system with method.
    msg = abcdchk(a,b,c,d);
    if (msg != "") { error(msg); }
  }}}


  nx = a.nr; na = a.nc;
  nb = b.nr; nu = b.nc;

  // --- Determine conversion method ---
  if (method=="zoh") {
    // Zero order hold approximation.
    </ac;bc/> = d2c(a,b,Ts);
    cc = c; dc = d;

  else if (method=="foh") {
    // First order hold approximation.
    if (sum(abs(eig(a).val)<length(a)*1.e-3)) {
      // Assume this plant generated by 'foh'
      if (tf) {
        tmp = tf2zp(num,den);
        z = tmp.z; p = tmp.p; k = tmp.k;
        ny = num.nr; m = num.nc;
        // Remove ny discrete differentiators
        zz = [];
        for (i in 1:ny ) {
          zi = z[;i];
          zi = zi[find(finite(zi))];		// Remove inf's
          m   = min(abs(zi-1));
          ndx = mini(abs(zi-1));
          if ((imag(zi[ndx])!=0)||(m>tol)) { 
             error("Zero at "+num2str(zi(ndx))+ ...
                " not close enough to z=1.  Can't convert using 'foh'.");
             return 1;
          }
          zi[ndx] = [];			// Remove one zero at z=1;
          mz = zz.nr; nz = zz.nc;
          nzi = length(zi);
          zz = [[zz;inf()*ones(max(0,nzi-mz),nz)],[zi;inf()*ones(max(0,mz-nzi),1)]];
        }
        m = min(abs(p));
        ndx = mini(abs(p));
        if ((imag(p(ndx))!=0)||(m>tol)) { 
          error("Discrete pole at "+num2str(p(ndx))+ ...
            " not close enough to z=0.  Can't convert using 'foh'."); 
          return 1;
        }
        p[ndx] = [];			// Remove one pole at z=0;
        </ad;bd;cd;dd/> = zp2ss(zz,p,k*Ts);
        </ac;bc/> = d2c(ad,bd,Ts);
        // Remove continuous integrators
        tmp = ss2zp(ac,bc,cd,dd,1);
        zc = tmp.z; pc = tmp.p; kc = tmp.k;
        m = min(abs(pc));
        ndx = mini(abs(pc));
        if ((imag(pc[ndx])!=0)||(m>tol)) { 
          error("Continuous pole at "+num2str(pc[ndx])+ ...
              " not close enough to s=0. Can't convert using 'foh'.");
          return 1;
        }
        pc[ndx] = [];			// Remove one pole at s=0;
        if (!isempty(zc)) {
          // Set zeros > 1.e9 to infinity
          zc[abs(zc)>1.e9] = inf()*ones(length(zc[abs(zc)>1.e9]),1);
        }
        </ac;bc;cc;dc/> = zp2ss(zc,pc,kc);

      else if (all(abs(a[1:nu;])<eps)) {
        // Check if system has correct structure
        // Remove discrete differentiators
        </ad;bd;cd;dd/> = ssdelete(a,b.*Ts,c,d.*Ts,[],[],[1:nu]);
        </ac;bc/> = d2c(ad,bd,Ts);
        // Remove continuous integrators
        n = ac.nr; m = ac.nc;
        bcc = ac[nu+1:n;1:nu]; 
        dcc = cd[;1:nu];
        </ac;bc;cc;dc/> = ssdelete(ac,bc,cd,dd,[],[],[1:nu]);
        bc=bcc; dc=dcc;
      else
        disp("WARNING: Can't use 'foh' for discrete plants not generated");
        disp("         by 'foh'.  Using D2C instead.");
        </ac;bc/> = d2c(a,b,Ts);
        cc = c; dc = d;
      }}
    else
      disp("WARNING: Can't use 'foh' for discrete plants not generated");
      disp("         by 'foh'.  Using D2C instead.");
      </ac;bc/> = d2c(a,b,Ts);
      cc = c; dc = d;
    }

  else if (method=="tustin") {
    // Tustin approximation.
    I = eye(nx,nx);
    r = 2/Ts;
    P = inv(I + a);
    ac = r*(a-I)*P;
    bc = 2*P*b;
    cc = r*c*P;
    dc = d - c*P*b;

  else if (method=="prewarp") {
    // Tustin approximation with frequency prewarping.
    if (!((nargs==5)||(nargs==7))) {
      error("The critical frequency must be specified when using 'prewarp'.");
    }
    T = 2*tan(w*Ts/2)/w;		// Prewarp
    I = eye(nx,nx);
    r = 2/T;
    P = inv(I + a);
    ac = r*(a-I)*P;
    bc = 2*P*b;
    cc = r*c*P;
    dc = d - c*P*b;
  
  else if (method=="mached") {
    // Matched pole-zero approximation.
    ny = d.nr; nu = d.nc;
    if ((ny>1)||(nu>1)) {
      error("System must be SISO for matched pole-zero method.");
    }
    if (tf) {
      z = roots(num); p = roots(den);
      kd = sum(num')'/sum(den);
    else
      tmp = ss2zp(a,b,c,d,1);
      z = tmp.z; p = tmp.p;
      kd = c/(eye(nx,nx)-a)*b + d;
    }
    z=esort(z).s; p = esort(p).s;
    pc = log(p)./Ts;
    zc = zeros(length(z),1);
    zinf = (abs(z+1)<eps);	// Fuzzy compare (z==-1)
    if (!isempty(zc)) {
      zc[!zinf] = log(z[!zinf])./Ts;
      zc[zinf] = inf()*ones(length(z[zinf]),1);
    }
    </ac;bc;cc;dc/> = zp2ss(zc,pc,1);

    // Match D.C. gain
    kc = -cc/ac*bc + dc;
    km = sqrt(abs(kd/kc));
    sm = sign(kd/kc);
    bc = bc.*km;
    cc = cc.*km.*sm;
    dc = dc.*km.*km.*sm;

  else
    error("Conversion method is unknown.");

  }}}}}

  #if nargout==0,		// Compare Bode or Singular value plots
  #  [ny,nc] = size(c);
  #  if (ny==1)&(nu==1),	// Plot Bode plots
  #    [magd,phased,wd] = dbode(a,b,c,d,Ts,1);
  #    [magc,phasec,wc] = bode(ac,bc,cc,dc,1);
  #    semilogx(wd,20*log10(magd),'-',wc,20*log10(magc),'--')
  #    xlabel('Frequency (rad/sec)'), ylabel('Gain dB')
  #    title('D2CM comparison plot')
  #  else
  #    [svd,wd] = dsigma(a,b,c,d,Ts);
  #    [svc,wc] = sigma(ac,bc,cc,dc);
  #    semilogx(wd,20*log10(svd),'-',wc,20*log10(svc),'--')
  #    xlabel('Frequency (rad/sec)'), ylabel('Singular Values dB')
  #    title('D2CM comparison plot')
  #  end
  #  return
  #end

  if(tf) {
    // Convert to TF form for output
    return ss2tf(ac,bc,cc,dc,1);
  }


  return <<ac=ac;bc=bc;cc=cc;dc=dc>>;
};

