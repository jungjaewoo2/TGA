      SUBROUTINE ROOT(A,FA,B,FB,U,FU,KOUNT,IFLAG,IERROR,EPMACH)
C
C***********************************************************************
C
C  ROOT SEEKS A ROOT OF THE EQUATION F(X)=0.0,
C  GIVEN A STARTING INTERVAL (A,B) ON WHICH F CHANGES SIGN.
C  ON FIRST CALL TO ROOT, THE INTERVAL AND FUNCTION VALUES FA AND FB
C  ARE INPUT AND AN APPROXIMATION U FOR THE ROOT IS RETURNED.
C  BEFORE EACH SUBSEQUENT CALL, THE USER EVALUATES FU=F(U), AND THE
C  PROGRAM TRIES TO RETURN A BETTER APPROXIMATION U.
C
C  SEE THE BOOK BY BRENT LISTED in the documentation.
C
C  VARIABLES
C
C  A     = IS ONE ENDPOINT OF AN INTERVAL IN WHICH F CHANGES SIGN.
C  FA    = THE VALUE OF F(A).  THE USER MUST EVALUATE F(A) BEFORE
C          FIRST CALL ONLY.  THEREAFTER THE PROGRAM SETS FA.
C  B     = IS THE OTHER ENDPOINT OF THE INTERVAL IN WHICH
C          F CHANGES SIGN.  NOTE THAT THE PROGRAM WILL RETURN
C          IMMEDIATELY WITH AN ERROR FLAG IF FB*FA.GT.0.0.
C  FB    = THE VALUE OF F(B).  THE USER MUST EVALUATE F(B) BEFORE
C          FIRST CALL ONLY.  THERAFTER THE PROGRAM SETS FB.
C  U     = ON FIRST CALL, U SHOULD NOT BE SET BY THE USER.
C          ON SUBSEQUENT CALLS, U SHOULD NOT BE CHANGED
C          FROM ITS OUTPUT VALUE, THE CURRENT APPROXIMANT
C          TO THE ROOT.
C  FU    = ON FIRST CALL, FU SHOULD NOT BE SET BY THE USER.
C          THEREAFTER, THE USER SHOULD EVALUATE THE FUNCTION
C          AT THE OUTPUT VALUE U, AND RETURN FU=F(U).
C  KOUNT = A COUNTER FOR THE NUMBER OF CALLS TO ROOT.  KOUNT
C          SHOULD BE SET TO ZERO ON THE FIRST CALL FOR A GIVEN
C          ROOT PROBLEM.
C  IFLAG = PROGRAM RETURN FLAG
C          IFLAG=-1  THE CURRENT BRACKETING INTERVAL WITH
C                    ENDPOINTS  STORED IN A AND B IS LESS THAN
C                    4*EPMACH*ABS(U)+EPMACH
C                    HENCE U SHOULD BE ACCEPTED AS THE ROOT.
C                    THE FUNCTION VALUE F(U) IS STORED IN FU.
C          IFLAG= 0  THE INPUT VALUE FU IS EXACTLY ZERO, AND
C                    U SHOULD BE ACCEPTED AS THE ROOT.
C          IFLAG>0   THE CURRENT APPROXIMATION TO THE ROOT IS
C                    CONTAINED IN U.  IF A BETTER APPROXIMATION IS
C                    DESIRED, SET FU=F(U) AND CALL ROOT AGAIN.
C                    THE VALUE OF IFLAG INDICATES
C                    THE METHOD THAT WAS USED TO PRODUCE U.
C
C          IFLAG= 1  BISECTION WAS USED.
C          IFLAG= 2  LINEAR INTERPOLATION (SECANT METHOD).
C          IFLAG= 3  INVERSE QUADRATIC INTERPOLATION.
C
C  IERROR= GLOBAL ERROR FLAG.
C          IERROR=0 NO ERROR FOUND
C          IERROR=7  ON FIRST CALL, FA*FB.GT.0.0. AND HENCE
C                    THE GIVEN INTERVAL IS UNACCEPTABLE.
C  EPMACH= THE RELATIVE MACHINE PRECISION
C
      DOUBLE PRECISION EIGHT
      DOUBLE PRECISION HALF
      DOUBLE PRECISION ONE
      DOUBLE PRECISION ONEP5
      DOUBLE PRECISION TWO
      DOUBLE PRECISION ZERO
C
      PARAMETER (EIGHT=8.0)
      PARAMETER (HALF=0.5)
      PARAMETER (ONE=1.0)
      PARAMETER (ONEP5=1.5)
      PARAMETER (TWO=2.0)
      PARAMETER (ZERO=0.0)
C
      INTRINSIC ABS
      INTRINSIC SIGN
C
      DOUBLE PRECISION A
      DOUBLE PRECISION B
      DOUBLE PRECISION EPMACH
      DOUBLE PRECISION FA
      DOUBLE PRECISION FB
      DOUBLE PRECISION FU
      DOUBLE PRECISION HALFUB
      INTEGER   IERROR
      INTEGER   IFLAG
      INTEGER   KOUNT
      DOUBLE PRECISION P
      DOUBLE PRECISION Q 
      DOUBLE PRECISION R
      DOUBLE PRECISION S
      DOUBLE PRECISION SDEL1
      DOUBLE PRECISION SDEL2
      DOUBLE PRECISION SDEL3
      DOUBLE PRECISION SDEL4
      DOUBLE PRECISION STEP
      DOUBLE PRECISION TOLER
      DOUBLE PRECISION U
C
C  SEGMENT 1   FIRST CALL HANDLED SPECIALLY.  DO BOOKKEEPING.
C
      IF(KOUNT.LE.0)THEN
        IF((FA.GT.ZERO.AND.FB.GT.ZERO) 
     1  .OR.(FA.LT.ZERO.AND.FB.LT.ZERO))THEN
          IERROR=7
          KOUNT=0
          RETURN
          ENDIF
        KOUNT=1
        SDEL1=TWO*ABS(B-A)
        SDEL2=TWO*SDEL1
        SDEL3=TWO*SDEL2
        U=B
        B=A
        FU=FB
        FB=FA
      ELSE
C
C  INCREMENT COUNTER AND CHECK WHETHER F(U)=0.
C
        KOUNT=KOUNT+1
        IF(FU.EQ.ZERO)THEN
          IFLAG=0
          RETURN
          ENDIF
C
C  IF FU AND FB HAVE THE SAME SIGN OVERWRITE B WITH A
C
        IF(SIGN(ONE,FU).EQ.SIGN(ONE,FB))THEN
          B=A
          FB=FA
          ENDIF
        ENDIF
C
C  SEGMENT 2   REARRANGE POINTS AND FUNCTION VALUES IF
C  NECESSARY SO THAT  ABS(FU).LT.ABS(FB)
C
      IF(ABS(FB).LT.ABS(FU)) THEN
        A=U
        U=B
        B=A
        FA=FU
        FU=FB
        FB=FA
        ENDIF
C
C  SEGMENT 3   CHECK FOR ACCEPTANCE BECAUSE OF SMALL INTERVAL
C  CURRENT CHANGE IN SIGN INTERVAL IS (B,U) OR (U,B).
C
      TOLER=TWO*EPMACH*ABS(U)+EPMACH
      HALFUB=HALF*(B-U)
      SDEL4=SDEL3
      SDEL3=SDEL2
      SDEL2=SDEL1
      SDEL1=ABS(B-U)
      IF(ABS(HALFUB).LE.TOLER) THEN
        IFLAG=-1
        A=U
        FA=FU
        RETURN
        ENDIF
C
C  SEGMENT 4   COMPUTE NEW APPROXIMANT TO ROOT OF THE FORM
C  U(NEW)=U(OLD)+STEP.
C  METHODS AVAILABLE ARE LINEAR INTERPOLATION
C  INVERSE QUADRATIC INTERPOLATION
C  AND BISECTION.
C
      IF(ABS(FU).GE.ABS(FA)) THEN
        IFLAG=1
        STEP=HALFUB
        GO TO 80
        ENDIF
C
C  ATTEMPT LINEAR INTERPOLATION IF ONLY TWO POINTS AVAILABLE
C  COMPUTE P AND Q FOR APPROXIMATION U(NEW)=U(OLD)+P/Q
C
      IF(A.EQ.B) THEN
        IFLAG=2
        S=FU/FA
        P=TWO*HALFUB*S
        Q=ONE-S
C    
C  ATTEMPT INVERSE QUADRATIC INTERPOLATION IF THREE POINTS AVAILABLE
C  COMPUTE P AND Q FOR APPROXIMATION U(NEW)=U(OLD)+P/Q
C
      ELSE
        IFLAG=3
        S=FU/FA
        Q=FA/FB
        R=FU/FB
        P=S*(TWO*HALFUB*Q*(Q-R)-(U-A)*(R-ONE))
        Q=(Q-ONE)*(R-ONE)*(S-ONE)
        ENDIF
C
C  CORRECT THE SIGNS OF P AND Q
C
      IF(P.GT.ZERO)Q=-Q
      P=ABS(P)
C
C  IF P/Q IS TOO LARGE, GO BACK TO BISECTION
C
      IF((EIGHT*SDEL1.GT.SDEL4) 
     1 .OR.(P.GE.ONEP5*ABS(HALFUB*Q)-ABS(TOLER*Q))) THEN
        IFLAG=1
        STEP=HALFUB
        GO TO 80
        ENDIF
      STEP=P/Q
C
C  SEGMENT 5   VALUE OF STEP HAS BEEN COMPUTED.
C  UPDATE INFORMATION  A =U, FA =FU, U =U+STEP.
C  CHANGE IN SIGN INTERVAL IS NOW (A,B) OR (B,A).
C
80    CONTINUE
      A=U
      FA=FU
      IF(ABS(STEP).LE.TOLER) STEP=SIGN(TOLER,HALFUB)
      U=U+STEP
      RETURN
      END 
