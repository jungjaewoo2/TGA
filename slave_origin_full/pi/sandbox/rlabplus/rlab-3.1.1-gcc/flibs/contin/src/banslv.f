      SUBROUTINE BANSLV(DETS,FX,DF,FPAR,IERROR,IPC,IPAR,IWORK,LIW,
     1 JOB,NVAR,RWORK,LRW,X,Y)
C
C***********************************************************************
C
C  BANSLV SOLVES A LINEAR SYSTEM OF THE FORM
C
C  ( DFDY  DFDZ )
C  (            ) * X=B
C  (   E(IPC)   )
C
C  WHERE DFDY IS FORMALLY AN (NVAR-1) BY (NVAR-1) MATRIX WHICH IS
C  TO BE STORED IN LINPACK GENERAL BAND STORAGE, DFDZ IS A COLUMN
C  VECTOR, AND E(IPC) IS AN NVAR-DIMENSIONAL ROW VECTOR WHICH IS 0
C  EXCEPT FOR A 1 IN THE IPC-TH POSITION.  IT IS ASSUMED THAT THE
C  FULL MATRIX ABOVE REPRESENTS THE JACOBIAN OF A SET OF NONLINEAR
C  EQUATIONS, WITH THE LAST EQUATION BEING X(IPC)=CONSTANT.
C
C  THE PURPOSE OF THIS ROUTINE IS TO SOLVE THE FULL SYSTEM, WHILE
C  TAKING ADVANTAGE OF SPECIAL PROPERTIES OF THE (NVAR-1) SUBSYSTEM
C  (IN THIS CASE BANDEDNESS), WHICH WOULD BE LOST IF THE FULL
C  SYSTEM WAS SOLVED DIRECTLY.
C
C  SEE THE PAPER BY CHAN LISTED ABOVE FOR DETAILS.
C
C  SUBROUTINE ARGUMENTS
C
C  DETS   - THE SIGN OF THE DETERMINANT OF THE FULL MATRIX.
C
C  FX     - AN EXTERNAL ROUTINE, THE NAME OF THE USER SUPPLIED
C           SUBROUTINE WHICH COMPUTES THE NVAR-1 DIMENSIONAL
C           FUNCTION.
C
C  DF     - AN EXTERNAL ROUTINE, THE NAME OF THE USER SUPPLIED
C           SUBROUTINE WHICH COMPUTES THE JACOBIAN OF THE NVAR-1
C           NONLINEAR FUNCTIONS.  THE LAST, AUGMENTING FUNCTION,
C           IS HANDLED BY THIS ROUTINE.  BECAUSE OF THE SPECIAL
C           STORAGE ARRANGEMENTS, GREAT CARE MUST BE TAKEN TO
C           STORE INFORMATION PROPERLY.
C
C           LET MU AND ML BE THE UPPER AND LOWER BANDWIDTHS.
C           THESE VALUES MUST BE STORED IN IPAR(*) AND IPAR(2),
C           RESPECTIVELY. SET NBAND=2*ML+MU+1.
C           THE INDEX K OF RWORK IN WHICH WE ARE TO STORE THE
C           (I,J) ENTRY OF THE JACOBIAN IS DETERMINED AS FOLLOWS:
C
C           IF(J.EQ.NVAR) K=(NVAR-1)*NBAND+I
C
C           OTHERWISE
C
C           IF((J-I.LE.ML).AND.(I-J.LE.MU)) K=I+J*(NBAND-1)-ML
C
C           FOR ALL OTHER VALUES OF I AND J THE ENTRY IS ZERO AND
C           NOT STORED.
C
C           THE FORM OF THE CALLING SEQUENCE OF DF IS
C           SUBROUTINE DF(NVAR,FPAR,IPAR,X,RWORK,IERR)
C           DIMENSION FPAR(*),IPAR(*),X(NVAR),RWORK(1)
C
C           SET IERR NONZERO IF EXECUTION IS TO BE HALTED FOR ANY REASON
C
C  FPAR   - A REAL ARRAY FOR TRANSMISSION OF PARAMETERS FROM THE
C           USER CALLING PROGRAM THROUGH THE CONTINUATION CODE TO
C           USER SUBROUTINES.  THE CONTINUATION CODE ASSUMES A
C           DIMENSION OF 1 FOR FPAR, AND NEVER ACCESSES ANY ENTRIES.
C
C  IERROR - ERROR RETURN FLAG.
C           IERROR= 0, NO ERRORS DETECTED.
C           IERROR= 1, DATA OR STORAGE ERROR.
C                      ILLEGAL VALUES OF NVAR, IPC, MU, ML, OR
C                      INSUFFICIENT STORAGE IN RWORK OR IWORK.
C           IERROR= 2, ERROR RETURN FROM DF.
C                      THE USER ROUTINE DF HAS SET AN ERROR FLAG.
C           IERROR= 3, NUMERICALLY SINGULAR MATRIX DETECTED.
C                      EITHER THE SUBMATRIX AS MODIFIED BY THIS
C                      ROUTINE IS SINGULAR, AND THE DECOMPOSITION
C                      OR THE CHOICE OF IPC IS INAPPROPRIATE,
C                      OR THE FULL SYSTEM MAY ACTUALLY BE SINGULAR.
C
C  IPC    - AN INDEX DETERMINED BY THE CONTINUATION CODE, WHICH
C           DEFINES THE AUGMENTING EQUATION, AND HENCE THE FORM
C           OF THE AUGMENTING ROW OF THE JACOBIAN.  THE FULL
C           ALGORITHM EMPLOYED HERE IS REALLY ONLY REQUIRED
C           WHEN IPC IS NOT EQUAL TO NVAR.  OTHERWISE, THE SOLUTION
C           IS QUITE EASY.
C
C  IPAR   - AN INTEGER ARRAY SIMILAR TO RPAR, EXCEPT THAT LOCATIONS
C           1 AND 2 OF IPAR ARE REFERENCED BY BANSLV.  IPAR(*)=ML,
C           THE LOWER BANDWIDTH OF THE JACOBIAN, AND IPAR(2)=MU,
C           THE UPPER BANDWIDTH.
C
C  IWORK  - AN INTEGER WORK ARRAY, USED BY THE CONTINUATION CODE
C           TO STORE STATISTICS, POINTERS, AND THE PIVOT VECTOR.
C           NOTE THAT IWORK(13) STORES THE FIRST ENTRY IN IWORK
C           DEVOTED TO THE PIVOT VECTOR, IWORK(15) STORES THE
C           FIRST ELEMENT OF RWORK DEVOTED TO THE JACOBIAN SUBSYSTEM.
C           IWORK(20) COUNTS MATRIX FACTORIZATIONS, AND IWORK(21)
C           COUNTS BACK-SOLVES.
C
C  LIW    - DIMENSION OF IWORK IN THE CALLING PROGRAM.
C
C  JOB    - WORK CONTROL SWITCH.
C           JOB=0, DECOMPOSE MATRIX, GET DETERMINANT, SOLVE SYSTEM.
C           JOB=1, SOLVE A NEW SYSTEM WITH SAME OLD MATRIX.
C           JOB=2, DECOMPOSE, COMPUTE DETERMINANT.
C           3, Check jacobian matrix.  Call user jacobian routine,
C           multiply by -1.0, add finite difference jacobian,
C           print largest entry.
C
C  NVAR   - THE NUMBER OF VARIABLES X, THE FORMAL DIMENSION OF
C           THE FULL LINEAR SYSTEM.
C
C  RWORK  - A REAL ARRAY USED FOR STORING THE MATRIX AND THE TWO
C           AUXILIARY VECTORS NEEDED.
C
C  LRW    - THE DIMENSION OF RWORK IN THE CALLING PROGRAM.
C
C  X      - A REAL VECTOR OF LENGTH NVAR, THE POINT AT WHICH
C           THE FULL LINEAR SYSTEM IS TO BE EVALUATED.
C
C  Y      - A REAL VECTOR OF LENGTH NVAR, WHICH ON INPUT IS
C           THE RIGHT HAND SIDE OF THE LINEAR SYSTEM TO BE SOLVED,
C           AND ON SUCCESSFUL RETURN WITH IERROR=0, IS THE
C           SOLUTION OF THAT LINEAR SYSTEM.
C
C
      DOUBLE PRECISION ONE
      DOUBLE PRECISION ZERO
C
      PARAMETER (ONE=1.0)
      PARAMETER (ZERO=0.0)
C
      EXTERNAL  BANJAC
      EXTERNAL  DF
      EXTERNAL  FX
      EXTERNAL  IDAMAX
      EXTERNAL  DAXPY
      EXTERNAL  DDOT
      EXTERNAL  DGBDI
      EXTERNAL  DGBFA
      EXTERNAL  DGBSL
      EXTERNAL  DSCAL
      EXTERNAL  DSWAP
C
      INTRINSIC MAX
      INTRINSIC MIN
      INTRINSIC SQRT
C
      INTEGER   LIW
      INTEGER   LRW
      INTEGER   NVAR
C
      DOUBLE PRECISION AK
      DOUBLE PRECISION DET(2)
      DOUBLE PRECISION DETS
      DOUBLE PRECISION EPS
      DOUBLE PRECISION FPAR(*)
      INTEGER   I
      INTEGER   IERROR
      INTEGER   IPAR(*)
      INTEGER   IPC
      INTEGER   IRL
      INTEGER   IRU
      INTEGER   IDAMAX
      INTEGER   ITEMP
      INTEGER   IWORK(LIW)
      INTEGER   J
      INTEGER   JAC
      INTEGER   JACK
      INTEGER   JOB
      INTEGER   JTEMP
      INTEGER   K
      INTEGER   LDFL
      INTEGER   LDFX
      INTEGER   LDX
      INTEGER   LFXM
      INTEGER   LFXP
      INTEGER   LILST
      INTEGER   LOUNIT
      INTEGER   LPIV
      INTEGER   LRLST
      INTEGER   LROWIP
      INTEGER   MBAND
      INTEGER   ML
      INTEGER   MU
      INTEGER   NBAND
      INTEGER   NDIM
      INTEGER   NEQN
      INTEGER   NSWAP
      DOUBLE PRECISION RWORK(LRW)
      DOUBLE PRECISION DDOT
      DOUBLE PRECISION SKALE
      DOUBLE PRECISION TEMP
      DOUBLE PRECISION X(NVAR)
      DOUBLE PRECISION Y(NVAR)
C
C  CHECK INPUT DATA
C
      IERROR=0
      LOUNIT=IWORK(8)
      ML=IPAR(1)
      MU=IPAR(2)
      NEQN=NVAR-1
      IF(ML.LT.0.OR.ML.GT.NEQN)THEN
        IERROR=1
        WRITE(LOUNIT,1020)ML
        RETURN
        ENDIF
      IF(MU.LT.0.OR.MU.GT.NEQN)THEN
        IERROR=1
        WRITE(LOUNIT,1030)MU
        RETURN
        ENDIF
      MBAND=ML+MU+1
      NBAND=MBAND+ML
      LPIV=IWORK(13)
      LILST=LPIV+NEQN-1
      LDFX=IWORK(15)
      LDFL=LDFX+NBAND*NEQN
      LROWIP=LDFL+NVAR
      JAC=IWORK(9)
      IF(JAC.EQ.0.AND.JOB.NE.3)THEN
        LRLST=LROWIP+NVAR-1
      ELSE
        LFXP=LROWIP+NVAR
        LFXM=LFXP+NVAR
        LDX=LFXM+NVAR
        LRLST=LDX+NVAR-1
        ENDIF
      NDIM=NEQN*NBAND+NVAR+NVAR-1
      IF(LILST.GT.LIW.OR.LRLST.GT.LRW)THEN
        WRITE(LOUNIT,1040)LILST,LIW
        WRITE(LOUNIT,1050)LRLST,LRW
        IERROR=1
        RETURN
        ENDIF
      IF(JOB.EQ.1)THEN
        IF(IPC.EQ.NVAR)THEN
          GO TO 70
        ELSE
          GO TO 40
        ENDIF
      ENDIF
C
C  JOB=0 OR 2 MEANS WE MUST EVALUATE THE JACOBIAN, EITHER WITH THE USER'S
C  ROUTINE OR BY FINITE DIFFERENCES, FACTOR IT AND GET THE SIGN
C  OF THE DETERMINANT
C
      DO 10 I=1,NDIM
        RWORK(LDFX+I-1)=ZERO
10      CONTINUE
      IF(JAC.EQ.0)THEN
        CALL DF(NVAR,FPAR,IPAR,X,RWORK(LDFX),IERROR)
        IWORK(19)=IWORK(19)+1
        IF(IERROR.NE.0)RETURN
        RWORK(LROWIP-1+IPC)=ONE
        ENDIF
      IF(JOB.EQ.3)THEN
        SKALE=-ONE
        CALL DSCAL(NDIM,SKALE,RWORK(LDFX),1)
        ENDIF
      IF(JAC.EQ.1.OR.JAC.EQ.2.OR.JOB.EQ.3)THEN
        JACK=JAC
        IF(JOB.EQ.3)JACK=2
        EPS=SQRT(SQRT(RWORK(8)))
        CALL BANJAC(EPS,RWORK(LDFL),FPAR,RWORK(LDFX),RWORK(LROWIP),
     *  FX,IERROR,IPAR,IPC,IWORK,JACK,LIW,LOUNIT,NBAND,NEQN,NVAR,X,
     *  RWORK(LDX),RWORK(LFXP),RWORK(LFXM))
        ENDIF
C
C  Figure out formulas for I and J
C
      IF(JOB.EQ.3)THEN
        K=IDAMAX(NDIM,RWORK(LDFX),1)
        AK=RWORK(LDFX+K-1)
        IF(K.LE.NEQN*NBAND)THEN
          J=((K-1)/NBAND)+1
          I=K-(J-1)*NBAND+J-ML-MU-1
        ELSEIF(K.LE.NEQN*NBAND+NEQN)THEN
          I=K-NEQN*NBAND
          J=NVAR
        ELSE
          I=NVAR
          J=K-NEQN*NBAND-NEQN
          ENDIF
        WRITE(LOUNIT,1070)AK,I,J
        IF(IWORK(1).EQ.-2)THEN
          WRITE(LOUNIT,*)' '
          WRITE(LOUNIT,*)'BANSLV - Entire difference matrix:'
          WRITE(LOUNIT,*)' '
          DO 99 I=1,NVAR
            DO 98 J=1,NVAR
              IF(J.EQ.NVAR)THEN
                K=LDFX-1+(NVAR-1)*NBAND+I
                WRITE(LOUNIT,1080)RWORK(K),I,J
              ELSEIF((J-I.LE.ML).AND.(I-J.LE.MU))THEN
                K=LDFX-1+I+J*(NBAND-1)-ML
                WRITE(LOUNIT,1080)RWORK(K),I,J
                ENDIF
98            CONTINUE
            WRITE(LOUNIT,*)' '
99          CONTINUE
          ENDIF
        RETURN
        ENDIF
      IF(IPC.EQ.NVAR)GO TO 60
C
C  SWITCH THE NVAR-TH AND IPC-TH ROWS.
C
      IRL=MAX(1,IPC-ML)
      IRU=MIN(NEQN,IPC+MU)
      NSWAP=IRU+1-IRL
      ITEMP=LDFX-ML-1+IPC+IRL*(NBAND-1)
      JTEMP=NBAND-1
      CALL DSWAP(NSWAP,RWORK(LROWIP-1+IRL),1,RWORK(ITEMP),JTEMP)
C
C  DECOMPOSE THE SUBMATRIX AND OBTAIN DETERMINANT SIGN
C
      CALL DGBFA(RWORK(LDFX),NBAND,NEQN,ML,MU,IWORK(LPIV),IERROR)
      IWORK(20)=IWORK(20)+1
      IF(IERROR.NE.0)THEN
        WRITE(LOUNIT,1000)IERROR,IPC
        IERROR=3
        RETURN
        ENDIF
      CALL DGBDI(RWORK(LDFX),NBAND,NEQN,ML,MU,IWORK(LPIV),DET)
      DETS=ZERO
      IF(DET(1).GT.ZERO)THEN
        DETS=-ONE
      ELSEIF(DET(1).LT.ZERO)THEN
        DETS=ONE
        ENDIF
C
C  SET THE RIGHT HAND SIDE OF THE AUXILLIARY SYSTEM TO
C  THE LAST COLUMN OF THE JACOBIAN, MINUS E(IPC).  SHUFFLE THE
C  IPC-TH AND NVAR-TH ENTRIES OF THIS RIGHT HAND SIDE
C  TO REFLECT THE PIVOTING OF THE EQUATIONS, THEN SOLVE.
C
      TEMP=RWORK(LDFL+IPC-1)-ONE
      RWORK(LDFL+IPC-1)=RWORK(LDFL+NVAR-1)
      RWORK(LDFL+NVAR-1)=TEMP
      CALL DGBSL(RWORK(LDFX),NBAND,NEQN,ML,MU,IWORK(LPIV),RWORK(LDFL)
     * ,0)
      IWORK(21)=IWORK(21)+1
C
C  SOLVE FOR LAST ENTRY OF AUXILLIARY SOLUTION
C
      RWORK(LDFL+NVAR-1)=RWORK(LDFL+NVAR-1)
     * -DDOT(NEQN,RWORK(LROWIP),1,RWORK(LDFL),1)
C
C  ADJUST DETERMINANT SIGN
C
      IF(ONE+RWORK(LDFL+NVAR-1).EQ.ZERO)THEN
        IERROR=3
        WRITE(LOUNIT,*)'BANSLV - Algorithm fails, DENOM=0.0'
        RETURN
        ENDIF
      IF(ONE+RWORK(LDFL+NVAR-1).LT.ZERO)DETS=-DETS
      IF(JOB.EQ.2)RETURN
C
C  SOLVE SYSTEM
C
40    CONTINUE
      IF(IPC.EQ.NVAR)GO TO 70
C
C  MODIFY RIGHT HAND SIDE OF MAIN SYSTEM
C
      TEMP=Y(IPC)
      Y(IPC)=Y(NVAR)
      Y(NVAR)=TEMP
C
C  SOLVE SUBSYSTEM
C
      CALL DGBSL(RWORK(LDFX),NBAND,NEQN,ML,MU,IWORK(LPIV),Y,0)
      IWORK(21)=IWORK(21)+1
C
C  SOLVE FOR LAST ENTRY OF MAIN SOLUTION
C
      Y(NVAR)=Y(NVAR)-DDOT(NEQN,RWORK(LROWIP),1,Y,1)
C
C  CORRECT MAIN SOLUTION WITH MULTIPLE OF SUBSOLUTION
C
      SKALE=-Y(NVAR)/(ONE+RWORK(LDFL+NVAR-1))
      CALL DAXPY(NVAR,SKALE,RWORK(LDFL),1,Y,1)
      RETURN
C
C  FACTOR MATRIX FOR THE SPECIAL CASE IPC=NVAR
C
   60 CONTINUE
      CALL DGBFA(RWORK(LDFX),NBAND,NEQN,ML,MU,IWORK(LPIV),IERROR)
      IWORK(20)=IWORK(20)+1
      IF(IERROR.NE.0)THEN
        WRITE(LOUNIT,1000)IERROR,IPC
        IERROR=3
        RETURN
        ENDIF
      CALL DGBDI(RWORK(LDFX),NBAND,NEQN,ML,MU,IWORK(LPIV),DET)
      DETS=ZERO
      IF(DET(1).LT.ZERO)THEN
        DETS=-ONE
      ELSEIF(DET(1).GT.ZERO)THEN
        DETS=ONE
        ENDIF
      IF(JOB.EQ.2)RETURN
C
C  SOLVE SYSTEM, FOR SPECIAL CASE IPC=NVAR
C
   70 CONTINUE
      SKALE=-Y(NVAR)
      CALL DAXPY(NEQN,SKALE,RWORK(LDFL),1,Y,1)
      CALL DGBSL(RWORK(LDFX),NBAND,NEQN,ML,MU,IWORK(LPIV),Y,0)
      IWORK(21)=IWORK(21)+1
      RETURN
1000  FORMAT(' BANSLV - Zero pivot, DGBFA returns INFO=',I6,' IPC=',I6)
1020  FORMAT(' BANSLV - Illegal ML=',I6)
1030  FORMAT(' BANSLV - Illegal MU=',I6)
1040  FORMAT(' BANSLV - Need LIW=',I6,', have LIW=',I6)
1050  FORMAT(' BANSLV - Need LRW=',I6,', have LRW=',I6)
1070  FORMAT(' BANSLV - Maximum difference between user and estimated'/
     *       '          jacobian is ',G14.6,' row ',I6,' column ',I6)
1080  FORMAT(1X,G14.6,' =FP(I,J)-DELF(I,J), I, J=',2I6)
      END
